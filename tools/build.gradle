apply plugin: "java"

sourceCompatibility = 1.8
sourceSets.main.java.srcDirs = [ "src/" ]


import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

import com.badlogic.gdx.tools.texturepacker.TexturePacker
import com.badlogic.gdx.utils.*
import com.badlogic.gdx.files.*
import com.badlogic.gdx.Gdx

def textureFolder = "../core/assets-raw/sprites/generated/"

task antialiasImages(){
    doLast{
        for(def img : project.getProperty("images").split(",")){
            println(project.getProperty("startdir") + "/" + img)
            antialias(new File(project.getProperty("startdir") + "/" + img))
        }
    }
}

task tileImages(){
    doLast{
        for(def img : project.getProperty("images").split(",")){
            println(project.getProperty("startdir") + "/" + img)
            tileImage(new File(project.getProperty("startdir") + "/" + img))
        }
    }
}

task pack(dependsOn: [classes, configurations.runtimeClasspath]){

    doLast{
        //cleanup old sprites
        delete{
            delete "../core/assets-raw/sprites_out/"
        }

        //copy in new sprites
        copy{
            from "../core/assets-raw/sprites/"
            into "../core/assets-raw/sprites_out/"
        }

        //run generation task; generate all needed sprites
        file(genFolder).mkdirs()
        javaexec{
            main = "mindustry.tools.ImagePacker"
            classpath = sourceSets.main.runtimeClasspath
            workingDir = genFolder
        }

        copy{
            from "../core/assets-raw/sprites_out/ui/icons"
            into "../core/assets-raw/sprites_out/ui/"
        }

        delete{
            delete "../core/assets-raw/sprites_out/ui/icons"
        }

        ExecutorService executor = Executors.newFixedThreadPool(16)
        long ms = System.currentTimeMillis()

        //antialias everything except UI elements
        fileTree(dir: new File(rootDir, 'core/assets-raw/sprites_out/').absolutePath, include: "**/*.png").visit{ file ->
            if(file.isDirectory() || (file.toString().replace("\\", "/").contains("/ui/") && file.toString().startsWith("icon-")) || file.toString().contains(".9.png")) return

            executor.submit{
                antialias(file.file)
            }
        }

        Threads.await(executor)

        println "Time taken for AA: ${(System.currentTimeMillis() - ms) / 1000f}"

        println("\n\nPacking normal 4096 sprites...\n\n")

        //pack normal sprites
        TexturePacker.process(new File(rootDir, "core/assets-raw/sprites_out/").absolutePath, new File(rootDir, "core/assets/sprites/").absolutePath, "sprites.aatls")

        println("\n\nPacking fallback 2048 sprites...\n\n")

        //replace config file contents
        fileTree(dir: '../core/assets-raw/sprites_out/', include: "**/*.json").visit{ file ->
            if(!file.isDirectory()) file.file.text = file.file.text.replace("4096", "2048")
        }

        //pack fallback 2048x2048 sprites
        TexturePacker.process(new File(rootDir, "core/assets-raw/sprites_out/").absolutePath, new File(rootDir, "core/assets/sprites/fallback/").absolutePath, "sprites.aatls")
    }
}

task generateSprites(dependsOn: classes, type: JavaExec) {
    file(textureFolder).mkdirs()

    main = "io.anuke.mindustry.PackerLauncher"
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = textureFolder
}

task fontgen(dependsOn: classes, type: JavaExec){
    main = "mindustry.tools.FontGenerator"
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = "../"
}

task icongen(dependsOn: classes, type: JavaExec){
    main = "mindustry.tools.IconConverter"
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = "../core/assets-raw"
}

task updateScripts(dependsOn: classes, type: JavaExec){
    main = "mindustry.tools.ScriptMainGenerator"
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = "../"
}

task updateBundles{
    doLast{
        def uniEscape = { String string ->
            StringBuilder outBuffer = new StringBuilder();
            int len = string.length();
            for(int i = 0; i < len; i++){
                char ch = string.charAt(i);
                if((ch > 61) && (ch < 127)){
                    outBuffer.append(ch == '\\' ? "\\\\" : ch);
                    continue;
                }

                if(ch >= 0xE000){
                    String hex = Integer.toHexString((int)ch);
                    outBuffer.append("\\u");
                    for(int j = 0; j < 4 - hex.length(); j++){
                        outBuffer.append('0');
                    }
                    outBuffer.append(hex);
                }else{
                    outBuffer.append(ch);
                }
            }

            return outBuffer.toString();
        }

        OrderedMap<String, String> base = new OrderedMap<>();
        PropertiesUtils.load(base, Gdx.files.internal("core/assets/bundles/bundle.properties").reader());
        Array<String> removals = new Array<>();

        def idkIJustWantThisToWork = {child ->
            if(child.name().equals("bundle.properties") || child.toString().contains("output")) return;

            Log.info("Parsing bundle: @", child);

            OrderedMap<String, String> other = new OrderedMap<>();

            //find the last known comment of each line
            ObjectMap<String, String> comments = new ObjectMap<>();
            StringBuilder curComment = new StringBuilder();

            for(String line : Array.with(child.readString().split("\n", -1))){
                if(line.startsWith("#") || line.isEmpty()){
                    curComment.append(line).append("\n");
                }else if(line.contains("=")){
                    String lastKey = line.substring(0, line.indexOf("=")).trim();
                    if(curComment.length() != 0){
                        comments.put(lastKey, curComment.toString());
                        curComment.setLength(0);
                    }
                }
            }

            ObjectMap<String, String> extras = new OrderedMap<>();
            PropertiesUtils.load(other, child.reader());
            removals.clear();

            for(String key : other.orderedKeys()){
                if(!base.containsKey(key) && key.contains(".details")){
                    extras.put(key, other.get(key));
                }else if(!base.containsKey(key)){
                    removals.add(key);
                    Log.info("&lr- Removing unused key '@'...", key);
                }
            }
            Log.info("&lr@ keys removed.", removals.size);
            for(String s : removals){
                other.remove(s);
            }

            int added = 0;

            for(String key : base.orderedKeys()){
                if(other.get(key) == null || other.get(key).trim().isEmpty()){
                    other.put(key, base.get(key));
                    added++;
                    Log.info("&lc- Adding missing key '@'...", key);
                }
            }

            Callable<String> processor = { key, value ->
                (comments.containsKey(key) ? comments.get(key) : "") + //append last known comment if present
                        (key + " =" + (value.trim().isEmpty() ? "" : " ") + uniEscape(value)).replace("\n", "\\n") + "\n";}
            FileHandle output = child.sibling("output/" + child.name());

            Log.info("&lc@ keys added.", added);
            Log.info("Writing bundle to @", output);
            StringBuilder result = new StringBuilder();

            //add everything ordered
            for(String key : base.orderedKeys().copy().and(extras.keys().toSeq())){
                if(other.get(key) == null) continue;

                result.append(processor.get(key, other.get(key)));
                other.remove(key);
            }

            child.writeString(result.toString());
        }

        for (FileHandle file : Gdx.files.internal("core/assets/bundles").list()){
            idkIJustWantThisToWork(file)
        };
    }
}
